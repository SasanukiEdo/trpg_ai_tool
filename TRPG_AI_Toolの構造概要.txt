## TRPG AI Tool 現状の構造概要（2025/5/7）

### 1. 主要ディレクトリとファイル構成

現在のプロジェクト (`trpg_ai_tool`) の主要なファイル構成は以下の通りです。UI関連 (`ui/`)、コアロジック関連 (`core/`)、データ関連 (`data/`) が分離されています。

*   `main.py`: アプリケーションのエントリーポイント。
*   **`core/`**: アプリケーションのコアロジックを格納するディレクトリ。
    *   `api_key_manager.py`: APIキーのOS資格情報ストアへの保存・取得・削除。
    *   `config_manager.py`: グローバル設定 (`config.json`) とプロジェクト設定 (`project_settings.json`) の読み書き、プロジェクトディレクトリの一覧取得・**削除**。
    *   `gemini_handler.py`: Google Gemini APIとの通信処理、クライアント設定。
    *   `subprompt_manager.py`: サブプロンプトデータ (`subprompts.json`) の読み書き。
*   **`ui/`**: PyQt5ベースのユーザーインターフェース関連ファイルを格納。
    *   `main_window.py`: メインウィンドウ (`MainWindow`)。UI全体の構築、イベント処理、コアロジック呼び出し、**プロジェクト選択・新規作成・削除機能**。
    *   `settings_dialog.py`: 設定ダイアログ (`SettingsDialog`)。
    *   `subprompt_dialog.py`: サブプロンプト編集ダイアログ (`SubPromptEditDialog`)。
    *   `data_widget.py`: データ管理エリア (`DataManagementWidget`)。カテゴリタブ、アイテムリスト表示。
    *   `detail_window.py`: アイテム詳細表示・編集ウィンドウ (`DetailWindow`)。**AI支援による履歴追記、履歴の編集・削除、画像プレビューの相対パス対応と表示安定化**。
    *   `data_item_widget.py`: データリストの各項目ウィジェット (`DataItemWidget`)。
    *   `ai_text_edit_dialog.py`: AI支援編集ダイアログ (`AIAssistedEditDialog`)。「説明/メモ」編集と**「履歴」追記支援**に利用。
*   **`data/{project_dir_name}/`**: 各プロジェクトのデータを格納するディレクトリ。
    *   `project_settings.json`: プロジェクト固有の設定（表示名、使用モデル、メインシステムプロンプトなど）。
    *   `subprompts.json`: プロジェクト固有のサブプロンプトデータ（カテゴリ別）。
    *   `gamedata/`: プロジェクトのゲームデータ（キャラクター、アイテムなど）をカテゴリ別にJSONファイルで格納するサブディレクトリ。
        *   `{category_name}.json`: 各カテゴリのアイテムデータを格納するJSONファイル。各アイテムにはID、名前、説明、履歴（各エントリにIDとタイムスタンプ、内容を保持）、タグ、画像パス（プロジェクト内`images/`からの相対パス）などが含まれる。
    *   **`images/` (新規)**: プロジェクトに関連する画像ファイル（アイテムの画像など）を格納するサブディレクトリ。アイテムデータ内の `image_path` は、このディレクトリからの相対パスで記録される。
    *   `data_manager.py`: カテゴリ別アイテムデータ (`gamedata/{category}.json`) の読み書き、アイテムのCRUD操作、履歴追加（各履歴にID付与）、**画像保存用ディレクトリ (`images/`) のパス取得・作成**。


### 2. 主要な処理フロー

*   **起動時**:
    1.  `main.py` が `MainWindow` をインスタンス化。
    2.  `MainWindow.__init__` が `_initialize_configs_and_project` を呼び出し。
    3.  `load_global_config` で `config.json` を読み込み、アクティブなプロジェクトディレクトリ名を取得。
    4.  `_load_current_project_data` が `load_project_settings` と `load_subprompts` を呼び出し、プロジェクトデータをメモリにロード。
    5.  `init_ui` でUIを構築。**プロジェクト選択コンボボックス (`_populate_project_selector`) も初期化**。
    6.  `configure_gemini` でAPIクライアントを設定。
*   **プロジェクト選択**:
    1.  ユーザーが `MainWindow` のプロジェクト選択コンボボックスでプロジェクトを選択。
    2.  `_on_project_selected_by_display_name` が選択された表示名に対応するディレクトリ名を取得し、`_switch_project` を呼び出す。
    3.  `_switch_project` は `current_project_dir_name` を更新し、`global_config` の `active_project` を更新・保存。
    4.  `_load_current_project_data` を呼び出し、新しいプロジェクトのデータをロード。
    5.  `MainWindow` のUI（メインプロンプト、ウィンドウタイトル）、`DataManagementWidget` の表示、`SubPromptTabWidget` の内容が新しいプロジェクトデータで更新される。
*   **新規プロジェクト作成**:
    1.  ユーザーが `MainWindow` の「新規作成」ボタンをクリック。
    2.  `_on_new_project_button_clicked` がプロジェクト表示名とディレクトリ名を入力するダイアログを表示。
    3.  `_validate_and_create_project` が入力を検証（重複・命名規則チェック）。
    4.  `core.config_manager.save_project_settings` (デフォルト設定で)、`core.subprompt_manager.save_subprompts` (空データで)、`core.data_manager.ensure_project_images_dir_exists` および `core.data_manager.create_category` (デフォルトの `images/` ディレクトリと「キャラクター」カテゴリ作成) を呼び出し、初期ファイル群を作成。
    5.  作成されたプロジェクトを `_switch_project` でアクティブ化し、プロジェクト選択コンボボックスを `_populate_project_selector` で更新。
*   **プロジェクト削除**:
    1.  ユーザーが `MainWindow` の「削除」ボタンをクリック。
    2.  `_on_delete_project_button_clicked` が確認ダイアログを表示。
    3.  承認されると `core.config_manager.delete_project_directory` でプロジェクトディレクトリ全体を削除。
    4.  プロジェクト選択コンボボックスを更新し、別のプロジェクトをアクティブにするか、プロジェクトなしの状態にUIを更新。
*   **AIとの対話**:
    1.  ユーザーが `MainWindow` の入力エリアにメッセージを入力し「送信」。
    2.  `on_send_button_clicked` がメインシステムプロンプト、選択されたサブプロンプト、選択されたデータアイテム情報を結合し、最終的なプロンプトを生成。
    3.  `core.gemini_handler.generate_response` を呼び出しAIからの応答を取得。
    4.  応答を `MainWindow` の表示エリアに表示。
*   **アイテム詳細表示・編集**:
    1.  ユーザーが `DataManagementWidget` のアイテムリストからアイテムを選択（またはアイテムのチェックボックス横の「詳細」ボタンをクリック）。
    2.  `DataManagementWidget.show_detail_window` が `DetailWindow` を表示し、該当アイテムのデータをロード。
    3.  ユーザーが `DetailWindow` で情報を編集し「保存」ボタンをクリック。
    4.  `DetailWindow.save_details` が `core.data_manager.update_item` を呼び出しデータを保存。`dataSaved` シグナルを発行。
*   **AI支援による「説明/メモ」編集**:
    1.  ユーザーが `DetailWindow` の「AIで「説明/メモ」を編集支援」ボタンをクリック。
    2.  `_on_ai_update_description_clicked` が `AIAssistedEditDialog` を「description」モードで起動。プロンプトテンプレートと現在の説明を渡す。
    3.  ユーザーがダイアログ内でAIに指示を出し、提案を編集して「OK」。
    4.  `DetailWindow` が最終テキストを取得し、`update_item` で保存。
*   **AI支援による「履歴」追記**:
    1.  ユーザーが `DetailWindow` の「AIで履歴エントリを生成・追加」ボタンをクリック。
    2.  `add_history_entry_with_ai_ui` が `AIAssistedEditDialog` を「history」モードで起動。プロンプトテンプレートと現在のアイテム情報を渡す。
    3.  ユーザーがダイアログ内でAIに指示を出し、提案を編集して「OK」。
    4.  `DetailWindow` が最終履歴エントリを取得し、`core.data_manager.add_history_entry` で保存（各履歴にIDが付与される）。UIが再ロードされ更新。
*   **履歴の編集・削除**:
    1.  ユーザーが `DetailWindow` の「履歴を編集/削除」ボタンをクリック。
    2.  `edit_history_entry_ui` / `delete_history_entry_ui` が番号入力ダイアログを表示。
    3.  ユーザーが番号を指定し、編集の場合は `QInputDialog.getMultiLineText` で編集。
    4.  対応する履歴エントリを `item_data['history']` から編集/削除し、`update_item` で保存。UIが再ロードされ更新。
*   **画像選択とプレビュー**:
    1.  ユーザーが `DetailWindow` で「画像を選択」ボタンをクリック。
    2.  `select_image_file` がファイルダイアログを表示。
    3.  選択された画像ファイルは、プロジェクトの `images/` ディレクトリに**ファイル名を変更せずにコピー**される。
    4.  アイテムデータの `image_path` には `images/ファイル名` という**相対パス**が保存される。
    5.  `_update_image_preview` が相対パスを解決し、**初回表示時も適切なサイズで、かつウィンドウリサイズに追従する形で**画像プレビューを表示する。

### 3. データフローと状態管理の詳細

*   **グローバル設定 (`MainWindow.global_config`)**: `data/config.json` からロード。アクティブプロジェクト名 (`active_project`)、デフォルトAIモデル名などを保持。設定ダイアログ経由で更新・保存。
*   **プロジェクト設定 (`MainWindow.current_project_settings`)**: 現在アクティブなプロジェクトの `project_settings.json` からロード。表示名、使用モデル、メインシステムプロンプトなどを保持。設定ダイアログや `MainWindow` のUI操作（メインプロンプト直接編集）で更新・保存。
*   **サブプロンプト (`MainWindow.subprompts`)**: 現在アクティブなプロジェクトの `subprompts.json` からロード。カテゴリ別のサブプロンプトデータを保持。サブプロンプト編集ダイアログ経由で更新・保存。チェック状態は `MainWindow.checked_subprompts` で管理。
*   **アイテムデータ (`DetailWindow.item_data`)**: `DataManagementWidget` で選択されたアイテムのデータ。`core.data_manager.get_item` でロード。`DetailWindow` での編集後、`core.data_manager.update_item` で対応するJSONファイルに保存。
    *   **`image_path`**: アイテムデータ内の画像パスは、プロジェクトルートからの相対パス（例: `images/character.png`）として保存される。
    *   **`history`**: アイテムデータ内の履歴はリスト形式で、各エントリは `{"id": "uuid-string", "timestamp": "YYYY-MM-DD HH:MM:SS", "entry": "内容"}` という辞書形式で保存される。タイムスタンプは内部データとして保持されるが、UI上ではデフォルト非表示。
*   **プロジェクト一覧の状態 (`MainWindow._projects_list_for_combo`)**: `list_project_dir_names()` と各プロジェクトの `project_settings.json` から読み取った表示名をタプル `(表示名, ディレクトリ名)` のリストとして保持し、プロジェクト選択コンボボックスの表示と選択処理に使用。
*   **UI間のデータ受け渡し**:
    *   `MainWindow` はアクティブなプロジェクトの各種データを保持し、必要に応じて `DataManagementWidget` や `SettingsDialog` に渡す。
    *   `DataManagementWidget` は選択されたアイテムのカテゴリとIDを `DetailWindow` に渡す。
    *   ダイアログ（`SettingsDialog`, `SubPromptEditDialog`, `AIAssistedEditDialog`, `QInputDialog`）は、呼び出し元のウィジェットから初期データを受け取り、編集結果を返す。



### 4. UIコンポーネント間の連携方法

*   **`MainWindow` ⇔ `DataManagementWidget`**:
    *   `MainWindow` → `DataManagementWidget`: `set_project(project_dir_name)` で表示対象プロジェクトを指示。
    *   `DataManagementWidget` → `MainWindow`: `addCategoryRequested`, `addItemRequested` シグナルを発行し、`MainWindow` が `QInputDialog` を表示して結果を `DataManagementWidget` のメソッド (`add_new_category_result`, `add_new_item_result`) に渡す。
*   **`DataManagementWidget` ⇔ `DetailWindow`**:
    *   `DataManagementWidget` → `DetailWindow`: アイテムリストでアイテムが選択されると `show_detail_window(category, item_id)` で `DetailWindow` を表示・データロード。
    *   `DetailWindow` → `DataManagementWidget`: `dataSaved(category, item_id)` シグナルを発行し、`DataManagementWidget` がリスト表示を更新 (`_handle_detail_saved`)。
*   **`MainWindow` ⇔ `SettingsDialog`**:
    *   `MainWindow` → `SettingsDialog`: 現在のグローバル設定とプロジェクト設定を渡してダイアログを初期化。
    *   `SettingsDialog` → `MainWindow`: ダイアログがAcceptedで閉じられたら、更新された設定データを返し、`MainWindow` が保存処理とUI更新（ウィンドウタイトル、メインプロンプト、**プロジェクト選択コンボボックス**）を行う。
*   **`MainWindow` ⇔ `SubPromptEditDialog`**:
    *   `MainWindow` → `SubPromptEditDialog`: 初期データ（編集時）または空データを渡してダイアログを初期化。
    *   `SubPromptEditDialog` → `MainWindow`: ダイアログがAcceptedで閉じられたら、編集されたサブプロンプトデータを返し、`MainWindow` が保存処理とサブプロンプトタブの更新を行う。
*   **`DetailWindow` ⇔ `AIAssistedEditDialog`**:
    *   `DetailWindow` → `AIAssistedEditDialog`: プロンプトテンプレート、現在のアイテム情報（説明や履歴）、編集モード（"description" or "history"）を渡してダイアログを初期化。
    *   `AIAssistedEditDialog` 内の「AIに提案を依頼」ボタン → `DetailWindow._handle_ai_suggestion_request` を呼び出し、AIに応答を要求。
    *   `AIAssistedEditDialog` → `DetailWindow`: ダイアログがAcceptedで閉じられたら、最終的な編集テキストを返し、`DetailWindow` が保存処理とUI更新を行う。
*   **`MainWindow`/`DetailWindow` ⇔ `QInputDialog`**:
    *   新規プロジェクト作成時、サブプロンプトカテゴリ追加時、データカテゴリ追加時、アイテム追加時、履歴編集・削除時に、ユーザーからの簡単なテキスト入力や数値入力を受け付けるために使用。


### 5. UIデザインとレイアウトに関するメモ（現状と今後の改善点）

*   **現状のUIデザイン**:
    *   メインウィンドウは左右2ペイン構成。
        *   左ペイン: メインシステムプロンプト入力、AI応答履歴表示、ユーザーメッセージ入力。
        *   右ペイン:
            *   **プロジェクト管理セクション**: 「プロジェクト管理:」ラベル（左揃え）と「新規作成」「削除」「設定」ボタン（右揃え）のヘッダー、その下に「選択中のプロジェクト:」ラベルとプロジェクト選択コンボボックス。
            *   **サブシステムプロンプト管理セクション**: 「サブシステムプロンプト管理:」ラベル（左揃え）と「カテゴリ追加」「プロンプト追加」ボタン（右揃え）のヘッダー、その下にサブプロンプトカテゴリタブ。
            *   **アイテム管理セクション**: 「アイテム管理:」ラベル（左揃え）と「カテゴリ追加」「アイテム追加」「チェック削除」ボタン（右揃え）のヘッダー、その下にデータ管理ウィジェット（アイテムカテゴリタブとアイテムリスト）。
            *   各セクション間には区切り線を挿入。
    *   アイテム詳細ウィンドウ (`DetailWindow`):
        *   スクロール可能なエリアにアイテムの各属性（名前、説明/メモ、履歴、タグ、画像）の表示・編集フィールドを配置。
        *   履歴表示: 通し番号付き、各エントリ間に区切り線、タイムスタンプはUI上非表示。履歴操作ボタン（AI支援追加、編集、削除）を配置。
        *   画像プレビュー: ウィンドウ下部に表示。**初回表示時も適切なサイズで表示され、ウィンドウリサイズに追従する。**
*   **今後の改善点**:
    *   `DetailWindow` の画像表示について、現在のプレビュー表示と、**ウィンドウ全体の背景として画像を表示するモードを切り替えられるようにする機能**。
    *   全体的なアイコンの統一や、より洗練されたカラースキームの検討。
    *   エラーメッセージやツールチップの充実。
    *   長文になりがちなAI応答履歴表示エリアのスクロール性改善や検索機能（任意）。
    *   各リスト（サブプロンプト、アイテム）の検索・フィルタリング機能。


### 6. 依存ライブラリと外部API

*   **PyQt5**: GUIフレームワーク。
*   **google-generativeai**: Gemini APIとの連携用。
*   **keyring**: APIキーのOS資格情報ストアへのアクセス用。
*   **標準ライブラリ**: `json`, `os`, `uuid`, `datetime` など。


### 7. 今後の拡張性に関する考慮事項

*   **モジュール性**: `core` と `ui` が分離されている点は良いです。`core` 内の各マネージャーも役割分担ができています。
*   **APIハンドラーの抽象化**: 現在は `gemini_handler` ですが、将来的に他のAIモデルに対応する場合、この部分を抽象化して、モデルごとのハンドラーを差し替えられるような設計にすると拡張性が高まります（例: 共通の `AIHandlerBase` クラスを作り、`GeminiHandler`, `ClaudeHandler` などがそれを継承する）。
*   **データ構造の変更への対応**: 新しい設定項目やデータフィールドを追加する場合、既存のJSONファイルとの互換性をどう保つか（マイグレーション処理など）を考慮する必要があります。`load_...` 関数内で、キーが存在しない場合にデフォルト値で補完する処理は、その一助となります。検索結果[1]はWebアプリの文脈ですが、「モデルファイル」という概念でデータ定義を一元管理する考え方は参考になります。


### 8. 今後の開発で特に意識する点

*   **プロジェクトコンテキスト**: ほとんどのデータ操作や設定は、`MainWindow` が保持する `self.current_project_dir_name` を基点に行われます。新しい機能を追加する際は、この「現在のプロジェクト」を意識し、各マネージャー関数に正しくプロジェクト名を渡す必要があります。
*   **UIとデータの同期**: プロジェクトが切り替わった場合（次のステップでUI実装予定）、またはデータが変更された場合に、UIの各部分（メインプロンプト入力欄、サブプロンプトタブ、データ管理タブ、ウィンドウタイトルなど）が適切に更新されるように、`_load_current_project_data()` や各種 `refresh_...()` メソッドの呼び出しタイミングが重要になります。
